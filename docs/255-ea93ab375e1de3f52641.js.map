{"version":3,"file":"255-ea93ab375e1de3f52641.js","mappings":"gOAcA,SAASA,EAAGC,GACV,IAAKA,EAAEC,GACL,MAAM,IAAIC,MAAMF,EAAEG,OAAS,IAAMH,EAAEI,YACrC,OAAOJ,EAAEK,MACX,CAOA,IAHYL,IAGA,gBAkWH,IA8KT,MAGGM,EAAK,CAAC,EAmONC,EAnOc,SAASP,GACxB,MAAMQ,EAAIC,OAAOC,KAAKV,GACtB,IAAK,MAAMW,KAAKH,EACdF,EAAGK,GAAKX,EAAEW,EACd,EAqOGC,EAAK,CACNC,OAAQ,IACRC,GAAI,IACJC,SAAU,IACVC,OAAQ,IACRC,KAAOjB,IACLA,EAAEkB,YAAclB,EAAEkB,UAAY,CAAC,GAAIlB,EAAEkB,UAAUC,oBAAsBnB,EAAEmB,oBAAqBZ,EAAWP,EAAEkB,WAAY,YAAW,WAAS,QAAQ,E","sources":["webpack://website-cyt/./node_modules/mermaid/dist/flowDiagram-7d05970f.js"],"sourcesContent":["import { p as St, f as $ } from \"./flowDb-39497bf7.js\";\nimport { h as S, u as Lt, r as Et, p as _t, l as Tt, d as D, f as tt, G as At } from \"./layout-492ec81d.js\";\nimport { h as x, m as et, g as J, f as rt, l as I } from \"./commonDb-41f8b4c5.js\";\nimport { a as A, b as at, i as nt, c as _, e as st, d as it, f as Nt, g as Ct } from \"./styles-3ce90e7a.js\";\nimport { l as It } from \"./line-05ccbb85.js\";\nimport { y as G, z as V, A as z, B as Bt } from \"./utils-8ea37061.js\";\nimport { s as Mt } from \"./selectAll-4d781168.js\";\nimport \"./mermaidAPI-67f627de.js\";\nimport \"./index-6271e032.js\";\nimport \"./edges-de377bae.js\";\nimport \"./createText-23817c58.js\";\nimport \"./svgDraw-0a992cdb.js\";\nimport \"./array-2ff2c7a6.js\";\nimport \"./constant-2fe7eae5.js\";\nfunction Dt(r) {\n  if (!r.ok)\n    throw new Error(r.status + \" \" + r.statusText);\n  return r.text();\n}\nfunction Pt(r, e) {\n  return fetch(r, e).then(Dt);\n}\nfunction Rt(r) {\n  return (e, t) => Pt(e, t).then((n) => new DOMParser().parseFromString(n, r));\n}\nvar Gt = Rt(\"image/svg+xml\"), Y = {\n  normal: Wt,\n  vee: $t,\n  undirected: zt\n};\nfunction Ut(r) {\n  Y = r;\n}\nfunction Wt(r, e, t, n) {\n  var a = r.append(\"marker\").attr(\"id\", e).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\"), s = a.append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  A(s, t[n + \"Style\"]), t[n + \"Class\"] && s.attr(\"class\", t[n + \"Class\"]);\n}\nfunction $t(r, e, t, n) {\n  var a = r.append(\"marker\").attr(\"id\", e).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\"), s = a.append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 L 4 5 z\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  A(s, t[n + \"Style\"]), t[n + \"Class\"] && s.attr(\"class\", t[n + \"Class\"]);\n}\nfunction zt(r, e, t, n) {\n  var a = r.append(\"marker\").attr(\"id\", e).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\"), s = a.append(\"path\").attr(\"d\", \"M 0 5 L 10 5\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  A(s, t[n + \"Style\"]), t[n + \"Class\"] && s.attr(\"class\", t[n + \"Class\"]);\n}\nfunction Vt(r, e) {\n  var t = r;\n  return t.node().appendChild(e.label), A(t, e.labelStyle), t;\n}\nfunction Yt(r, e) {\n  for (var t = r.append(\"text\"), n = Ht(e.label).split(`\n`), a = 0; a < n.length; a++)\n    t.append(\"tspan\").attr(\"xml:space\", \"preserve\").attr(\"dy\", \"1em\").attr(\"x\", \"1\").text(n[a]);\n  return A(t, e.labelStyle), t;\n}\nfunction Ht(r) {\n  for (var e = \"\", t = !1, n, a = 0; a < r.length; ++a)\n    if (n = r[a], t) {\n      switch (n) {\n        case \"n\":\n          e += `\n`;\n          break;\n        default:\n          e += n;\n      }\n      t = !1;\n    } else\n      n === \"\\\\\" ? t = !0 : e += n;\n  return e;\n}\nfunction K(r, e, t) {\n  var n = e.label, a = r.append(\"g\");\n  e.labelType === \"svg\" ? Vt(a, e) : typeof n != \"string\" || e.labelType === \"html\" ? at(a, e) : Yt(a, e);\n  var s = a.node().getBBox(), i;\n  switch (t) {\n    case \"top\":\n      i = -e.height / 2;\n      break;\n    case \"bottom\":\n      i = e.height / 2 - s.height;\n      break;\n    default:\n      i = -s.height / 2;\n  }\n  return a.attr(\"transform\", \"translate(\" + -s.width / 2 + \",\" + i + \")\"), a;\n}\nvar H = function(r, e) {\n  var t = e.nodes().filter(function(s) {\n    return nt(e, s);\n  }), n = r.selectAll(\"g.cluster\").data(t, function(s) {\n    return s;\n  });\n  _(n.exit(), e).style(\"opacity\", 0).remove();\n  var a = n.enter().append(\"g\").attr(\"class\", \"cluster\").attr(\"id\", function(s) {\n    var i = e.node(s);\n    return i.id;\n  }).style(\"opacity\", 0).each(function(s) {\n    var i = e.node(s), o = x(this);\n    x(this).append(\"rect\");\n    var c = o.append(\"g\").attr(\"class\", \"label\");\n    K(c, i, i.clusterLabelPos);\n  });\n  return n = n.merge(a), n = _(n, e).style(\"opacity\", 1), n.selectAll(\"rect\").each(function(s) {\n    var i = e.node(s), o = x(this);\n    A(o, i.style);\n  }), n;\n};\nfunction Xt(r) {\n  H = r;\n}\nlet X = function(r, e) {\n  var t = r.selectAll(\"g.edgeLabel\").data(e.edges(), function(a) {\n    return st(a);\n  }).classed(\"update\", !0);\n  t.exit().remove(), t.enter().append(\"g\").classed(\"edgeLabel\", !0).style(\"opacity\", 0), t = r.selectAll(\"g.edgeLabel\"), t.each(function(a) {\n    var s = x(this);\n    s.select(\".label\").remove();\n    var i = e.edge(a), o = K(s, e.edge(a), 0).classed(\"label\", !0), c = o.node().getBBox();\n    i.labelId && o.attr(\"id\", i.labelId), S(i, \"width\") || (i.width = c.width), S(i, \"height\") || (i.height = c.height);\n  });\n  var n;\n  return t.exit ? n = t.exit() : n = t.selectAll(null), _(n, e).style(\"opacity\", 0).remove(), t;\n};\nfunction Ft(r) {\n  X = r;\n}\nfunction O(r, e) {\n  return r.intersect(e);\n}\nvar F = function(r, e, t) {\n  var n = r.selectAll(\"g.edgePath\").data(e.edges(), function(i) {\n    return st(i);\n  }).classed(\"update\", !0), a = Zt(n, e);\n  Ot(n, e);\n  var s = n.merge !== void 0 ? n.merge(a) : n;\n  return _(s, e).style(\"opacity\", 1), s.each(function(i) {\n    var o = x(this), c = e.edge(i);\n    c.elem = this, c.id && o.attr(\"id\", c.id), it(\n      o,\n      c.class,\n      (o.classed(\"update\") ? \"update \" : \"\") + \"edgePath\"\n    );\n  }), s.selectAll(\"path.path\").each(function(i) {\n    var o = e.edge(i);\n    o.arrowheadId = Lt(\"arrowhead\");\n    var c = x(this).attr(\"marker-end\", function() {\n      return \"url(\" + Qt(location.href, o.arrowheadId) + \")\";\n    }).style(\"fill\", \"none\");\n    _(c, e).attr(\"d\", function(d) {\n      return Jt(e, d);\n    }), A(c, o.style);\n  }), s.selectAll(\"defs *\").remove(), s.selectAll(\"defs\").each(function(i) {\n    var o = e.edge(i), c = t[o.arrowhead];\n    c(x(this), o.arrowheadId, o, \"arrowhead\");\n  }), s;\n};\nfunction qt(r) {\n  F = r;\n}\nfunction Qt(r, e) {\n  var t = r.split(\"#\")[0];\n  return t + \"#\" + e;\n}\nfunction Jt(r, e) {\n  var t = r.edge(e), n = r.node(e.v), a = r.node(e.w), s = t.points.slice(1, t.points.length - 1);\n  return s.unshift(O(n, s[0])), s.push(O(a, s[s.length - 1])), ot(t, s);\n}\nfunction ot(r, e) {\n  var t = (It || Gt.line)().x(function(n) {\n    return n.x;\n  }).y(function(n) {\n    return n.y;\n  });\n  return (t.curve || t.interpolate)(r.curve), t(e);\n}\nfunction Kt(r) {\n  var e = r.getBBox(), t = r.ownerSVGElement.getScreenCTM().inverse().multiply(r.getScreenCTM()).translate(e.width / 2, e.height / 2);\n  return { x: t.e, y: t.f };\n}\nfunction Zt(r, e) {\n  var t = r.enter().append(\"g\").attr(\"class\", \"edgePath\").style(\"opacity\", 0);\n  return t.append(\"path\").attr(\"class\", \"path\").attr(\"d\", function(n) {\n    var a = e.edge(n), s = e.node(n.v).elem, i = Et(a.points.length).map(function() {\n      return Kt(s);\n    });\n    return ot(a, i);\n  }), t.append(\"defs\"), t;\n}\nfunction Ot(r, e) {\n  var t = r.exit();\n  _(t, e).style(\"opacity\", 0).remove();\n}\nvar q = function(r, e, t) {\n  var n = e.nodes().filter(function(i) {\n    return !nt(e, i);\n  }), a = r.selectAll(\"g.node\").data(n, function(i) {\n    return i;\n  }).classed(\"update\", !0);\n  a.exit().remove(), a.enter().append(\"g\").attr(\"class\", \"node\").style(\"opacity\", 0), a = r.selectAll(\"g.node\"), a.each(function(i) {\n    var o = e.node(i), c = x(this);\n    it(\n      c,\n      o.class,\n      (c.classed(\"update\") ? \"update \" : \"\") + \"node\"\n    ), c.select(\"g.label\").remove();\n    var d = c.append(\"g\").attr(\"class\", \"label\"), l = K(d, o), v = t[o.shape], h = _t(l.node().getBBox(), \"width\", \"height\");\n    o.elem = this, o.id && c.attr(\"id\", o.id), o.labelId && d.attr(\"id\", o.labelId), S(o, \"width\") && (h.width = o.width), S(o, \"height\") && (h.height = o.height), h.width += o.paddingLeft + o.paddingRight, h.height += o.paddingTop + o.paddingBottom, d.attr(\n      \"transform\",\n      \"translate(\" + (o.paddingLeft - o.paddingRight) / 2 + \",\" + (o.paddingTop - o.paddingBottom) / 2 + \")\"\n    );\n    var u = x(this);\n    u.select(\".label-container\").remove();\n    var p = v(u, h, o).classed(\"label-container\", !0);\n    A(p, o.style);\n    var m = p.node().getBBox();\n    o.width = m.width, o.height = m.height;\n  });\n  var s;\n  return a.exit ? s = a.exit() : s = a.selectAll(null), _(s, e).style(\"opacity\", 0).remove(), a;\n};\nfunction jt(r) {\n  q = r;\n}\nfunction te(r, e) {\n  var t = r.filter(function() {\n    return !x(this).classed(\"update\");\n  });\n  function n(a) {\n    var s = e.node(a);\n    return \"translate(\" + s.x + \",\" + s.y + \")\";\n  }\n  t.attr(\"transform\", n), _(r, e).style(\"opacity\", 1).attr(\"transform\", n), _(t.selectAll(\"rect\"), e).attr(\"width\", function(a) {\n    return e.node(a).width;\n  }).attr(\"height\", function(a) {\n    return e.node(a).height;\n  }).attr(\"x\", function(a) {\n    var s = e.node(a);\n    return -s.width / 2;\n  }).attr(\"y\", function(a) {\n    var s = e.node(a);\n    return -s.height / 2;\n  });\n}\nfunction ee(r, e) {\n  var t = r.filter(function() {\n    return !x(this).classed(\"update\");\n  });\n  function n(a) {\n    var s = e.edge(a);\n    return S(s, \"x\") ? \"translate(\" + s.x + \",\" + s.y + \")\" : \"\";\n  }\n  t.attr(\"transform\", n), _(r, e).style(\"opacity\", 1).attr(\"transform\", n);\n}\nfunction re(r, e) {\n  var t = r.filter(function() {\n    return !x(this).classed(\"update\");\n  });\n  function n(a) {\n    var s = e.node(a);\n    return \"translate(\" + s.x + \",\" + s.y + \")\";\n  }\n  t.attr(\"transform\", n), _(r, e).style(\"opacity\", 1).attr(\"transform\", n);\n}\nfunction lt(r, e, t, n) {\n  var a = r.x, s = r.y, i = a - n.x, o = s - n.y, c = Math.sqrt(e * e * o * o + t * t * i * i), d = Math.abs(e * t * i / c);\n  n.x < a && (d = -d);\n  var l = Math.abs(e * t * o / c);\n  return n.y < s && (l = -l), { x: a + d, y: s + l };\n}\nfunction ae(r, e, t) {\n  return lt(r, e, e, t);\n}\nfunction ne(r, e, t, n) {\n  var a, s, i, o, c, d, l, v, h, u, p, m, f, y, k;\n  if (a = e.y - r.y, i = r.x - e.x, c = e.x * r.y - r.x * e.y, h = a * t.x + i * t.y + c, u = a * n.x + i * n.y + c, !(h !== 0 && u !== 0 && j(h, u)) && (s = n.y - t.y, o = t.x - n.x, d = n.x * t.y - t.x * n.y, l = s * r.x + o * r.y + d, v = s * e.x + o * e.y + d, !(l !== 0 && v !== 0 && j(l, v)) && (p = a * o - s * i, p !== 0)))\n    return m = Math.abs(p / 2), f = i * d - o * c, y = f < 0 ? (f - m) / p : (f + m) / p, f = s * c - a * d, k = f < 0 ? (f - m) / p : (f + m) / p, { x: y, y: k };\n}\nfunction j(r, e) {\n  return r * e > 0;\n}\nfunction T(r, e, t) {\n  var n = r.x, a = r.y, s = [], i = Number.POSITIVE_INFINITY, o = Number.POSITIVE_INFINITY;\n  e.forEach(function(p) {\n    i = Math.min(i, p.x), o = Math.min(o, p.y);\n  });\n  for (var c = n - r.width / 2 - i, d = a - r.height / 2 - o, l = 0; l < e.length; l++) {\n    var v = e[l], h = e[l < e.length - 1 ? l + 1 : 0], u = ne(\n      r,\n      t,\n      { x: c + v.x, y: d + v.y },\n      { x: c + h.x, y: d + h.y }\n    );\n    u && s.push(u);\n  }\n  return s.length ? (s.length > 1 && s.sort(function(p, m) {\n    var f = p.x - t.x, y = p.y - t.y, k = Math.sqrt(f * f + y * y), B = m.x - t.x, E = m.y - t.y, U = Math.sqrt(B * B + E * E);\n    return k < U ? -1 : k === U ? 0 : 1;\n  }), s[0]) : (console.log(\"NO INTERSECTION FOUND, RETURN NODE CENTER\", r), r);\n}\nfunction Z(r, e) {\n  var t = r.x, n = r.y, a = e.x - t, s = e.y - n, i = r.width / 2, o = r.height / 2, c, d;\n  return Math.abs(s) * i > Math.abs(a) * o ? (s < 0 && (o = -o), c = s === 0 ? 0 : o * a / s, d = o) : (a < 0 && (i = -i), c = i, d = a === 0 ? 0 : i * s / a), { x: t + c, y: n + d };\n}\nvar Q = {\n  rect: ie,\n  ellipse: oe,\n  circle: le,\n  diamond: ce\n};\nfunction se(r) {\n  Q = r;\n}\nfunction ie(r, e, t) {\n  var n = r.insert(\"rect\", \":first-child\").attr(\"rx\", t.rx).attr(\"ry\", t.ry).attr(\"x\", -e.width / 2).attr(\"y\", -e.height / 2).attr(\"width\", e.width).attr(\"height\", e.height);\n  return t.intersect = function(a) {\n    return Z(t, a);\n  }, n;\n}\nfunction oe(r, e, t) {\n  var n = e.width / 2, a = e.height / 2, s = r.insert(\"ellipse\", \":first-child\").attr(\"x\", -e.width / 2).attr(\"y\", -e.height / 2).attr(\"rx\", n).attr(\"ry\", a);\n  return t.intersect = function(i) {\n    return lt(t, n, a, i);\n  }, s;\n}\nfunction le(r, e, t) {\n  var n = Math.max(e.width, e.height) / 2, a = r.insert(\"circle\", \":first-child\").attr(\"x\", -e.width / 2).attr(\"y\", -e.height / 2).attr(\"r\", n);\n  return t.intersect = function(s) {\n    return ae(t, n, s);\n  }, a;\n}\nfunction ce(r, e, t) {\n  var n = e.width * Math.SQRT2 / 2, a = e.height * Math.SQRT2 / 2, s = [\n    { x: 0, y: -a },\n    { x: -n, y: 0 },\n    { x: 0, y: a },\n    { x: n, y: 0 }\n  ], i = r.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    s.map(function(o) {\n      return o.x + \",\" + o.y;\n    }).join(\" \")\n  );\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction de() {\n  var r = function(e, t) {\n    fe(t);\n    var n = P(e, \"output\"), a = P(n, \"clusters\"), s = P(n, \"edgePaths\"), i = X(P(n, \"edgeLabels\"), t), o = q(P(n, \"nodes\"), t, Q);\n    Tt(t), re(o, t), ee(i, t), F(s, t, Y);\n    var c = H(a, t);\n    te(c, t), pe(t);\n  };\n  return r.createNodes = function(e) {\n    return arguments.length ? (jt(e), r) : q;\n  }, r.createClusters = function(e) {\n    return arguments.length ? (Xt(e), r) : H;\n  }, r.createEdgeLabels = function(e) {\n    return arguments.length ? (Ft(e), r) : X;\n  }, r.createEdgePaths = function(e) {\n    return arguments.length ? (qt(e), r) : F;\n  }, r.shapes = function(e) {\n    return arguments.length ? (se(e), r) : Q;\n  }, r.arrows = function(e) {\n    return arguments.length ? (Ut(e), r) : Y;\n  }, r;\n}\nvar he = {\n  paddingLeft: 10,\n  paddingRight: 10,\n  paddingTop: 10,\n  paddingBottom: 10,\n  rx: 0,\n  ry: 0,\n  shape: \"rect\"\n}, ue = {\n  arrowhead: \"normal\",\n  curve: G\n};\nfunction fe(r) {\n  r.nodes().forEach(function(e) {\n    var t = r.node(e);\n    !S(t, \"label\") && !r.children(e).length && (t.label = e), S(t, \"paddingX\") && D(t, {\n      paddingLeft: t.paddingX,\n      paddingRight: t.paddingX\n    }), S(t, \"paddingY\") && D(t, {\n      paddingTop: t.paddingY,\n      paddingBottom: t.paddingY\n    }), S(t, \"padding\") && D(t, {\n      paddingLeft: t.padding,\n      paddingRight: t.padding,\n      paddingTop: t.padding,\n      paddingBottom: t.padding\n    }), D(t, he), tt([\"paddingLeft\", \"paddingRight\", \"paddingTop\", \"paddingBottom\"], function(n) {\n      t[n] = Number(t[n]);\n    }), S(t, \"width\") && (t._prevWidth = t.width), S(t, \"height\") && (t._prevHeight = t.height);\n  }), r.edges().forEach(function(e) {\n    var t = r.edge(e);\n    S(t, \"label\") || (t.label = \"\"), D(t, ue);\n  });\n}\nfunction pe(r) {\n  tt(r.nodes(), function(e) {\n    var t = r.node(e);\n    S(t, \"_prevWidth\") ? t.width = t._prevWidth : delete t.width, S(t, \"_prevHeight\") ? t.height = t._prevHeight : delete t.height, delete t._prevWidth, delete t._prevHeight;\n  });\n}\nfunction P(r, e) {\n  var t = r.select(\"g.\" + e);\n  return t.empty() && (t = r.append(\"g\").attr(\"class\", e)), t;\n}\nfunction ct(r, e, t) {\n  const n = e.width, a = e.height, s = (n + a) * 0.9, i = [\n    { x: s / 2, y: 0 },\n    { x: s, y: -s / 2 },\n    { x: s / 2, y: -s },\n    { x: 0, y: -s / 2 }\n  ], o = N(r, s, s, i);\n  return t.intersect = function(c) {\n    return T(t, i, c);\n  }, o;\n}\nfunction dt(r, e, t) {\n  const a = e.height, s = a / 4, i = e.width + 2 * s, o = [\n    { x: s, y: 0 },\n    { x: i - s, y: 0 },\n    { x: i, y: -a / 2 },\n    { x: i - s, y: -a },\n    { x: s, y: -a },\n    { x: 0, y: -a / 2 }\n  ], c = N(r, i, a, o);\n  return t.intersect = function(d) {\n    return T(t, o, d);\n  }, c;\n}\nfunction ht(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: -a / 2, y: 0 },\n    { x: n, y: 0 },\n    { x: n, y: -a },\n    { x: -a / 2, y: -a },\n    { x: 0, y: -a / 2 }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction ut(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: -2 * a / 6, y: 0 },\n    { x: n - a / 6, y: 0 },\n    { x: n + 2 * a / 6, y: -a },\n    { x: a / 6, y: -a }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction ft(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: 2 * a / 6, y: 0 },\n    { x: n + a / 6, y: 0 },\n    { x: n - 2 * a / 6, y: -a },\n    { x: -a / 6, y: -a }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction pt(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: -2 * a / 6, y: 0 },\n    { x: n + 2 * a / 6, y: 0 },\n    { x: n - a / 6, y: -a },\n    { x: a / 6, y: -a }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction vt(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: a / 6, y: 0 },\n    { x: n - a / 6, y: 0 },\n    { x: n + 2 * a / 6, y: -a },\n    { x: -2 * a / 6, y: -a }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction yt(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: 0, y: 0 },\n    { x: n + a / 2, y: 0 },\n    { x: n, y: -a / 2 },\n    { x: n + a / 2, y: -a },\n    { x: 0, y: -a }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction gt(r, e, t) {\n  const n = e.height, a = e.width + n / 4, s = r.insert(\"rect\", \":first-child\").attr(\"rx\", n / 2).attr(\"ry\", n / 2).attr(\"x\", -a / 2).attr(\"y\", -n / 2).attr(\"width\", a).attr(\"height\", n);\n  return t.intersect = function(i) {\n    return Z(t, i);\n  }, s;\n}\nfunction mt(r, e, t) {\n  const n = e.width, a = e.height, s = [\n    { x: 0, y: 0 },\n    { x: n, y: 0 },\n    { x: n, y: -a },\n    { x: 0, y: -a },\n    { x: 0, y: 0 },\n    { x: -8, y: 0 },\n    { x: n + 8, y: 0 },\n    { x: n + 8, y: -a },\n    { x: -8, y: -a },\n    { x: -8, y: 0 }\n  ], i = N(r, n, a, s);\n  return t.intersect = function(o) {\n    return T(t, s, o);\n  }, i;\n}\nfunction wt(r, e, t) {\n  const n = e.width, a = n / 2, s = a / (2.5 + n / 50), i = e.height + s, o = \"M 0,\" + s + \" a \" + a + \",\" + s + \" 0,0,0 \" + n + \" 0 a \" + a + \",\" + s + \" 0,0,0 \" + -n + \" 0 l 0,\" + i + \" a \" + a + \",\" + s + \" 0,0,0 \" + n + \" 0 l 0,\" + -i, c = r.attr(\"label-offset-y\", s).insert(\"path\", \":first-child\").attr(\"d\", o).attr(\"transform\", \"translate(\" + -n / 2 + \",\" + -(i / 2 + s) + \")\");\n  return t.intersect = function(d) {\n    const l = Z(t, d), v = l.x - t.x;\n    if (a != 0 && (Math.abs(v) < t.width / 2 || Math.abs(v) == t.width / 2 && Math.abs(l.y - t.y) > t.height / 2 - s)) {\n      let h = s * s * (1 - v * v / (a * a));\n      h != 0 && (h = Math.sqrt(h)), h = s - h, d.y - t.y > 0 && (h = -h), l.y += h;\n    }\n    return l;\n  }, c;\n}\nfunction ve(r) {\n  r.shapes().question = ct, r.shapes().hexagon = dt, r.shapes().stadium = gt, r.shapes().subroutine = mt, r.shapes().cylinder = wt, r.shapes().rect_left_inv_arrow = ht, r.shapes().lean_right = ut, r.shapes().lean_left = ft, r.shapes().trapezoid = pt, r.shapes().inv_trapezoid = vt, r.shapes().rect_right_inv_arrow = yt;\n}\nfunction ye(r) {\n  r({ question: ct }), r({ hexagon: dt }), r({ stadium: gt }), r({ subroutine: mt }), r({ cylinder: wt }), r({ rect_left_inv_arrow: ht }), r({ lean_right: ut }), r({ lean_left: ft }), r({ trapezoid: pt }), r({ inv_trapezoid: vt }), r({ rect_right_inv_arrow: yt });\n}\nfunction N(r, e, t, n) {\n  return r.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    n.map(function(a) {\n      return a.x + \",\" + a.y;\n    }).join(\" \")\n  ).attr(\"transform\", \"translate(\" + -e / 2 + \",\" + t / 2 + \")\");\n}\nconst ge = {\n  addToRender: ve,\n  addToRenderV2: ye\n}, xt = {}, me = function(r) {\n  const e = Object.keys(r);\n  for (const t of e)\n    xt[t] = r[t];\n}, bt = function(r, e, t, n, a, s) {\n  const i = n ? n.select(`[id=\"${t}\"]`) : x(`[id=\"${t}\"]`), o = a || document;\n  Object.keys(r).forEach(function(d) {\n    const l = r[d];\n    let v = \"default\";\n    l.classes.length > 0 && (v = l.classes.join(\" \"));\n    const h = V(l.styles);\n    let u = l.text !== void 0 ? l.text : l.id, p;\n    if (et(J().flowchart.htmlLabels)) {\n      const y = {\n        label: u.replace(\n          /fa[blrs]?:fa-[\\w-]+/g,\n          (k) => `<i class='${k.replace(\":\", \" \")}'></i>`\n        )\n      };\n      p = at(i, y).node(), p.parentNode.removeChild(p);\n    } else {\n      const y = o.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n      y.setAttribute(\"style\", h.labelStyle.replace(\"color:\", \"fill:\"));\n      const k = u.split(rt.lineBreakRegex);\n      for (const B of k) {\n        const E = o.createElementNS(\"http://www.w3.org/2000/svg\", \"tspan\");\n        E.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\"), E.setAttribute(\"dy\", \"1em\"), E.setAttribute(\"x\", \"1\"), E.textContent = B, y.appendChild(E);\n      }\n      p = y;\n    }\n    let m = 0, f = \"\";\n    switch (l.type) {\n      case \"round\":\n        m = 5, f = \"rect\";\n        break;\n      case \"square\":\n        f = \"rect\";\n        break;\n      case \"diamond\":\n        f = \"question\";\n        break;\n      case \"hexagon\":\n        f = \"hexagon\";\n        break;\n      case \"odd\":\n        f = \"rect_left_inv_arrow\";\n        break;\n      case \"lean_right\":\n        f = \"lean_right\";\n        break;\n      case \"lean_left\":\n        f = \"lean_left\";\n        break;\n      case \"trapezoid\":\n        f = \"trapezoid\";\n        break;\n      case \"inv_trapezoid\":\n        f = \"inv_trapezoid\";\n        break;\n      case \"odd_right\":\n        f = \"rect_left_inv_arrow\";\n        break;\n      case \"circle\":\n        f = \"circle\";\n        break;\n      case \"ellipse\":\n        f = \"ellipse\";\n        break;\n      case \"stadium\":\n        f = \"stadium\";\n        break;\n      case \"subroutine\":\n        f = \"subroutine\";\n        break;\n      case \"cylinder\":\n        f = \"cylinder\";\n        break;\n      case \"group\":\n        f = \"rect\";\n        break;\n      default:\n        f = \"rect\";\n    }\n    I.warn(\"Adding node\", l.id, l.domId), e.setNode(s.db.lookUpDomId(l.id), {\n      labelType: \"svg\",\n      labelStyle: h.labelStyle,\n      shape: f,\n      label: p,\n      rx: m,\n      ry: m,\n      class: v,\n      style: h.style,\n      id: s.db.lookUpDomId(l.id)\n    });\n  });\n}, kt = function(r, e, t) {\n  let n = 0, a, s;\n  if (r.defaultStyle !== void 0) {\n    const i = V(r.defaultStyle);\n    a = i.style, s = i.labelStyle;\n  }\n  r.forEach(function(i) {\n    n++;\n    var o = \"L-\" + i.start + \"-\" + i.end, c = \"LS-\" + i.start, d = \"LE-\" + i.end;\n    const l = {};\n    i.type === \"arrow_open\" ? l.arrowhead = \"none\" : l.arrowhead = \"normal\";\n    let v = \"\", h = \"\";\n    if (i.style !== void 0) {\n      const u = V(i.style);\n      v = u.style, h = u.labelStyle;\n    } else\n      switch (i.stroke) {\n        case \"normal\":\n          v = \"fill:none\", a !== void 0 && (v = a), s !== void 0 && (h = s);\n          break;\n        case \"dotted\":\n          v = \"fill:none;stroke-width:2px;stroke-dasharray:3;\";\n          break;\n        case \"thick\":\n          v = \" stroke-width: 3.5px;fill:none\";\n          break;\n      }\n    l.style = v, l.labelStyle = h, i.interpolate !== void 0 ? l.curve = z(i.interpolate, G) : r.defaultInterpolate !== void 0 ? l.curve = z(r.defaultInterpolate, G) : l.curve = z(xt.curve, G), i.text === void 0 ? i.style !== void 0 && (l.arrowheadStyle = \"fill: #333\") : (l.arrowheadStyle = \"fill: #333\", l.labelpos = \"c\", et(J().flowchart.htmlLabels) ? (l.labelType = \"html\", l.label = `<span id=\"L-${o}\" class=\"edgeLabel L-${c}' L-${d}\" style=\"${l.labelStyle}\">${i.text.replace(\n      /fa[blrs]?:fa-[\\w-]+/g,\n      (u) => `<i class='${u.replace(\":\", \" \")}'></i>`\n    )}</span>`) : (l.labelType = \"text\", l.label = i.text.replace(rt.lineBreakRegex, `\n`), i.style === void 0 && (l.style = l.style || \"stroke: #333; stroke-width: 1.5px;fill:none\"), l.labelStyle = l.labelStyle.replace(\"color:\", \"fill:\"))), l.id = o, l.class = c + \" \" + d, l.minlen = i.length || 1, e.setEdge(t.db.lookUpDomId(i.start), t.db.lookUpDomId(i.end), l, n);\n  });\n}, we = function(r, e) {\n  I.info(\"Extracting classes\"), e.db.clear();\n  try {\n    return e.parse(r), e.db.getClasses();\n  } catch (t) {\n    return I.error(t), {};\n  }\n}, xe = function(r, e, t, n) {\n  I.info(\"Drawing flowchart\"), n.db.clear();\n  const { securityLevel: a, flowchart: s } = J();\n  let i;\n  a === \"sandbox\" && (i = x(\"#i\" + e));\n  const o = a === \"sandbox\" ? x(i.nodes()[0].contentDocument.body) : x(\"body\"), c = a === \"sandbox\" ? i.nodes()[0].contentDocument : document;\n  try {\n    n.parser.parse(r);\n  } catch {\n    I.debug(\"Parsing failed\");\n  }\n  let d = n.db.getDirection();\n  d === void 0 && (d = \"TD\");\n  const l = s.nodeSpacing || 50, v = s.rankSpacing || 50, h = new At({\n    multigraph: !0,\n    compound: !0\n  }).setGraph({\n    rankdir: d,\n    nodesep: l,\n    ranksep: v,\n    marginx: 8,\n    marginy: 8\n  }).setDefaultEdgeLabel(function() {\n    return {};\n  });\n  let u;\n  const p = n.db.getSubGraphs();\n  for (let g = p.length - 1; g >= 0; g--)\n    u = p[g], n.db.addVertex(u.id, u.title, \"group\", void 0, u.classes);\n  const m = n.db.getVertices();\n  I.warn(\"Get vertices\", m);\n  const f = n.db.getEdges();\n  let y = 0;\n  for (y = p.length - 1; y >= 0; y--) {\n    u = p[y], Mt(\"cluster\").append(\"text\");\n    for (let g = 0; g < u.nodes.length; g++)\n      I.warn(\n        \"Setting subgraph\",\n        u.nodes[g],\n        n.db.lookUpDomId(u.nodes[g]),\n        n.db.lookUpDomId(u.id)\n      ), h.setParent(n.db.lookUpDomId(u.nodes[g]), n.db.lookUpDomId(u.id));\n  }\n  bt(m, h, e, o, c, n), kt(f, h, n);\n  const k = new de();\n  ge.addToRender(k), k.arrows().none = function(b, L, w, M) {\n    const C = b.append(\"marker\").attr(\"id\", L).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 0 0 L 0 0 L 0 0 z\");\n    A(C, w[M + \"Style\"]);\n  }, k.arrows().normal = function(b, L) {\n    b.append(\"marker\").attr(\"id\", L).attr(\"viewBox\", \"0 0 10 10\").attr(\"refX\", 9).attr(\"refY\", 5).attr(\"markerUnits\", \"strokeWidth\").attr(\"markerWidth\", 8).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\").append(\"path\").attr(\"d\", \"M 0 0 L 10 5 L 0 10 z\").attr(\"class\", \"arrowheadPath\").style(\"stroke-width\", 1).style(\"stroke-dasharray\", \"1,0\");\n  };\n  const B = o.select(`[id=\"${e}\"]`), E = o.select(\"#\" + e + \" g\");\n  for (k(E, h), E.selectAll(\"g.node\").attr(\"title\", function() {\n    return n.db.getTooltip(this.id);\n  }), n.db.indexNodes(\"subGraph\" + y), y = 0; y < p.length; y++)\n    if (u = p[y], u.title !== \"undefined\") {\n      const g = c.querySelectorAll(\n        \"#\" + e + ' [id=\"' + n.db.lookUpDomId(u.id) + '\"] rect'\n      ), b = c.querySelectorAll(\n        \"#\" + e + ' [id=\"' + n.db.lookUpDomId(u.id) + '\"]'\n      ), L = g[0].x.baseVal.value, w = g[0].y.baseVal.value, M = g[0].width.baseVal.value, C = x(b[0]).select(\".label\");\n      C.attr(\"transform\", `translate(${L + M / 2}, ${w + 14})`), C.attr(\"id\", e + \"Text\");\n      for (let W = 0; W < u.classes.length; W++)\n        b[0].classList.add(u.classes[W]);\n    }\n  if (!s.htmlLabels) {\n    const g = c.querySelectorAll('[id=\"' + e + '\"] .edgeLabel .label');\n    for (const b of g) {\n      const L = b.getBBox(), w = c.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      w.setAttribute(\"rx\", 0), w.setAttribute(\"ry\", 0), w.setAttribute(\"width\", L.width), w.setAttribute(\"height\", L.height), b.insertBefore(w, b.firstChild);\n    }\n  }\n  Bt(h, B, s.diagramPadding, s.useMaxWidth), Object.keys(m).forEach(function(g) {\n    const b = m[g];\n    if (b.link) {\n      const L = o.select(\"#\" + e + ' [id=\"' + n.db.lookUpDomId(g) + '\"]');\n      if (L) {\n        const w = c.createElementNS(\"http://www.w3.org/2000/svg\", \"a\");\n        w.setAttributeNS(\"http://www.w3.org/2000/svg\", \"class\", b.classes.join(\" \")), w.setAttributeNS(\"http://www.w3.org/2000/svg\", \"href\", b.link), w.setAttributeNS(\"http://www.w3.org/2000/svg\", \"rel\", \"noopener\"), a === \"sandbox\" ? w.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", \"_top\") : b.linkTarget && w.setAttributeNS(\"http://www.w3.org/2000/svg\", \"target\", b.linkTarget);\n        const M = L.insert(function() {\n          return w;\n        }, \":first-child\"), R = L.select(\".label-container\");\n        R && M.append(function() {\n          return R.node();\n        });\n        const C = L.select(\".label\");\n        C && M.append(function() {\n          return C.node();\n        });\n      }\n    }\n  });\n}, be = {\n  setConf: me,\n  addVertices: bt,\n  addEdges: kt,\n  getClasses: we,\n  draw: xe\n}, Re = {\n  parser: St,\n  db: $,\n  renderer: Nt,\n  styles: Ct,\n  init: (r) => {\n    r.flowchart || (r.flowchart = {}), r.flowchart.arrowMarkerAbsolute = r.arrowMarkerAbsolute, be.setConf(r.flowchart), $.clear(), $.setGen(\"gen-1\");\n  }\n};\nexport {\n  Re as diagram\n};\n//# sourceMappingURL=flowDiagram-7d05970f.js.map\n"],"names":["Dt","r","ok","Error","status","statusText","text","xt","be","e","Object","keys","t","Re","parser","db","renderer","styles","init","flowchart","arrowMarkerAbsolute"],"sourceRoot":""}